<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        let width, height;
        
        function resizeCanvas() {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, width, height);
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Shader sources
        const vertexShaderSource = `
            attribute vec2 aPosition;
            varying vec2 vUv;
            void main() {
                vUv = aPosition * 0.5 + 0.5;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            varying vec2 vUv;
            
            void main() {
                vec2 uv = vUv;
                vec4 color = texture2D(uTexture, uv);
                color *= 0.98; // Fade effect
                gl_FragColor = color;
            }
        `;
        
        const splatShaderSource = `
            precision highp float;
            uniform sampler2D uTexture;
            uniform vec2 uPoint;
            uniform vec3 uColor;
            uniform float uRadius;
            uniform vec2 uResolution;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv - uPoint / uResolution;
                p.x *= uResolution.x / uResolution.y;
                float splat = exp(-dot(p, p) / uRadius);
                vec3 base = texture2D(uTexture, vUv).rgb;
                gl_FragColor = vec4(base + uColor * splat, 1.0);
            }
        `;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const splatFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, splatShaderSource);
        
        const displayProgram = createProgram(gl, vertexShader, fragmentShader);
        const splatProgram = createProgram(gl, vertexShader, splatFragmentShader);
        
        // Create quad buffer
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        // Create textures and framebuffers
        function createDoubleFBO(w, h) {
            const fbo1 = createFBO(w, h);
            const fbo2 = createFBO(w, h);
            return {
                read: fbo1,
                write: fbo2,
                swap: function() {
                    const temp = this.read;
                    this.read = this.write;
                    this.write = temp;
                }
            };
        }
        
        function createFBO(w, h) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            return {
                texture: texture,
                fbo: fbo,
                width: w,
                height: h
            };
        }
        
        let dye = createDoubleFBO(width, height);
        
        let pointers = [];
        
        canvas.addEventListener('mousemove', (e) => {
            pointers[0] = { x: e.clientX, y: e.clientY, dx: e.movementX, dy: e.movementY };
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touches = e.targetTouches;
            for (let i = 0; i < touches.length; i++) {
                pointers[i] = {
                    x: touches[i].clientX,
                    y: touches[i].clientY,
                    dx: 0,
                    dy: 0
                };
            }
        }, { passive: false });
        
        function splat(x, y, dx, dy) {
            gl.useProgram(splatProgram);
            
            const aPosition = gl.getAttribLocation(splatProgram, 'aPosition');
            gl.enableVertexAttribArray(aPosition);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTexture'), 0);
            gl.uniform2f(gl.getUniformLocation(splatProgram, 'uPoint'), x, height - y);
            gl.uniform2f(gl.getUniformLocation(splatProgram, 'uResolution'), width, height);
            
            const color = [
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5
            ];
            gl.uniform3fv(gl.getUniformLocation(splatProgram, 'uColor'), color);
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'uRadius'), 0.001);
            
            gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
            gl.bindFramebuffer(gl.FRAMEBUFFER, dye.write.fbo);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            dye.swap();
        }
        
        function render() {
            resizeCanvas();
            
            if (dye.read.width !== width || dye.read.height !== height) {
                dye = createDoubleFBO(width, height);
            }
            
            // Apply splats
            for (let i = 0; i < pointers.length; i++) {
                const pointer = pointers[i];
                if (pointer && (pointer.dx !== 0 || pointer.dy !== 0)) {
                    splat(pointer.x, pointer.y, pointer.dx, pointer.dy);
                }
            }
            
            // Display
            gl.useProgram(displayProgram);
            
            const aPosition = gl.getAttribLocation(displayProgram, 'aPosition');
            gl.enableVertexAttribArray(aPosition);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uTexture'), 0);
            gl.uniform2f(gl.getUniformLocation(displayProgram, 'uResolution'), width, height);
            
            gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>
